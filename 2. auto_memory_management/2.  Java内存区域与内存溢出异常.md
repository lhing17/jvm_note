### 2.1 概述

本章介绍Java虚拟机内存的各个区域，讲解这些区域的作用、服务对象及可能产生的问题

### 2.2 运行时数据区域

#### 程序计数器

- 字节码行号（偏移量）指示器
- 线程私有
- 执行native方法时，计数器值为空（undefined）
- 唯一在JVM规范中没有规定任何OutOfMemoryError的区域

#### Java虚拟机栈

- 线程私有，生命周期与线程相同
- 每个方法执行时创建一个栈帧，存储局部变量 表、操作数栈、动态连接、方法入口等信息
- 在该区域线程请求栈深度大于虚拟机所允许的深度，抛出StackOverflowError
- 在该区域虚拟机栈容量动态扩展时无法申请到足够内存，抛出OutOfMemoryError

#### 本地方法栈

- 与虚拟机栈类似，用于执行本地（native）方法
- HotSpot虚拟机中，本地方法栈与虚拟机栈合二为一

#### Java堆

- JVM管理内存中最大的一块，用于存放对象实例
- 所有线程共享，可划分出多个线程私有的分配缓冲区（TLAB）
- 物理上不必连续，逻辑上必须连续
- 如果堆内存上无法完成对象实例分配，并且堆无法扩展，抛出OutOfMemoryError

#### 方法区

- 线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
- JDK 8以前（不含8），HotSpot虚拟机通过永久代来实现方法区
- JDK 7时，HotSpot将字符串常量池、静态变量等移出永久代；JDK 8时，使用元空间代替了永久代
- 方法区无法满足新的内存分配需求时，抛出OutOfMemoryError

#### 运行时常量池

- 方法区的一部分
- Class文件中的常量池表在类加载时放入方法区中

#### 直接内存

- JDK 1.4中引入的NIO类可以使用native函数库直接分配堆外内存
- 各个内存区域总和大于物理内存限制时出现OutOfMemoryError
- *元空间（Metaspace）的内存区域属于直接内存

### 2.3 HotSpot虚拟机对象探秘

#### 对象的创建

- 类未被加载，先执行类加载过程
- 接下来虚拟机为新对象分配内存，有两种方式：指针碰撞和空闲列表，采用哪种由内存是否规整决定
- 将分配到的内存空间初始化为零值
- 将对象的哈希码、GC年龄等信息存到对象头中
- 虚拟机中对象已创建完成，接下来执行<init>方法对对象进行初始化

#### 对象的内存布局

- 对象内存布局三部分：对象头、实例数据、对齐填充
- 对象头信息分为两类：对象自身运行数据（Mark Word）、类型指针
- 如果对象是数组，头部还需要存储数组长度
- HotSpot分配实例数据的默认顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（普通对象指针），即相同长度在一起
- 如果实例数据长度不是8字节的倍数，需要进行对齐填充

#### 对象的访问定位

- 对象访问方式由虚拟机实现决定，主要包括句柄访问和直接指针访问
- 句柄包含对象实例数据和类型数据的地址
- 句柄访问较稳定，直接指针访问速度更快

### 2.4 实战：OutOfMemoryError异常

#### Java堆溢出
#### 虚拟机栈和本地方法栈溢出
#### 方法区和运行时常量池溢出
#### 本机直接内存溢出

