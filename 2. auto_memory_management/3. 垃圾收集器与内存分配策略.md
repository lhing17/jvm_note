### 3.1 概述

垃圾收集器关注的是运行期动态分配的内存如何管理

### 3.2 对象已死？

#### 引用计数算法

- 有地方引用对象，计数器加一；引用失效时，计数器减一；计数器为零的对象不再使用
- 缺陷是不会回收互相引用的对象

#### 可达性分析算法

- 某个对象与GC Roots为起始节点集间没有任何引用链相连，证明该对象不再使用
- GC Roots包括：
    - 虚拟机栈中引用的对象
    - 方法区中类静态属性引用的对象
    - 方法区中常量引用的对象
    - 本地方法栈中JNI引用的对象
    - JVM内部引用
    - 所有被同步锁（synchronized关键字）持有的对象
    - 反映JVM内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等
    - 某些“临时性”加入的对象
- 为了避免GC Roots包含过多对象，很多收集器都具备局部回收特征

#### 再谈引用

- Java中引用分为强引用、软引用、弱引用和虚引用四种：
    - 强引用指引用赋值，GC永远不会回收被强引用的对象
    - 软引用指有用但非必须的对象，软引用的对象在系统要发生OOM前会被列入GC回收范围
    - 弱引用用来描述非必须对象，只生存到下一次GC发生为止
    - 虚引用唯一目的是对象在GC回收时会收到一个系统通知
    
#### 生存还是死亡？

- 对象宣告死亡之前至少经历两次标记过程：
    - 可达性分析判定为不可达时
    - finalize()方法执行前，收集器会对F-Queue对象进行第二次小规模标记
- 不推荐人为调用finalize()方法

#### 回收方法区

- 《Java虚拟机规范》不要求方法区实现垃圾收集
- 方法区垃圾回收性价比低，主要收集废弃常量和不再使用的类型
- 不再使用的类型需同时满足三个条件：
    - 类所有的实例都被回收
    - 加载该类的类加载器被回收
    - 该类的Class对象没有任何对象引用（无法通过反射访问该类）
    
### 3.3 垃圾收集算法

大致分为引用计数式垃圾收集（直接垃圾收集）和追踪式垃圾收集（间接垃圾收集）两类。本节主要介绍追踪式垃圾收集。

#### 分代收集理论

- 分代收集的理论依据——分代假说：
    - 弱分代假说：大多数对象朝生夕灭
    - 强分代假说：熬过越多次GC过程的对象越难以消亡
    - 跨代引用假说：跨代引用相对于同代引用来说仅占极少数
- 堆内存通常划分为新生代和老年代
- GC根据分代情况分为几种：
    - Minor GC/ Young GC：回收新生代
    - Major GC/ Old GC：单独收集老年代，目前仅CMS收集器有
    - Mixed GC：回收整个新生代和部分老年代，目前仅G1收集器有
    - Full GC：回收整个Java堆和方法区，有时Major GC指的是Full GC
    
#### 标记-清除算法

#### 标记-复制算法

#### 标记-整理算法
